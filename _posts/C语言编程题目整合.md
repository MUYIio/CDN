---
title: C语言编程题目整合
top: false
cover: false
toc: true
mathjax: true
date: 2020-04-13 14:50:08
password:
summary: 做过的题目渐渐变得生疏，索性记录在博客上，看着更直观些，好记性不如烂笔头！
tags:
- 学习笔记
- 代码整合
categories:
- C语言
---





**做过的题目渐渐变得生疏，索性记录在博客上，看着更直观些，好记性不如烂笔头！**

------



### 1.数值变换

**【问题描述】**

 编写一程序，从键盘输入输入一个三位正整数，然后反向输出对应的数，如果输入的数不是三位正整数，则输出－1。 

**【输入形式】** 

从键盘输入三位的正整数。 

**【输出形式】**

 输出交换后的正整数值。 

**【输入样例】**

 356  

**【输出样例】**

 653 

**【样例说明】**

从键盘输入的正整数值为356，将该数的个位与百位互换，所得结果为653.如果输入的正整数为300，则输出为3。 

**【评分标准】** 

结果完全正确得20分，每个测试点4分。



```c
#include <stdio.h>
int main()
{
	int a, b, c, d;
	scanf("%d",&a);
	if(a>=100&&a<1000)
	{
		b=a/100;	
		c=a%100/10;
		d=a%10;
		if(d==0&&c==0)
			printf("%d",b);
		else if(d==0)
			printf("%d%d",c,b);
		else
			printf("%d%d%d",d,c,b);
	}
	else
		printf("-1");
} 
```

------



### 2.sinx计算公式

**【问题描述】**

已知sinx的近似计算公式如下： sin x = x - x3/3! + x5/5! - x7/7! + ... + (-1)n-1x2n-1/(2n-1)! 其中x为弧度，n为正整数。编写程序根据用户输入的x和n的值，利用上述近似计算公式计算sinx的近似值，要求输出结果小数点后保留8位。

**【输入形式】**

从控制台输入小数x（0<=x<=20）和整数n（1<=n<=5000），两数中间用空格分隔。

**【输出形式】**

控制台输出公式结果：小数点后保留8位。

**【样例输入1】**

0.5236 4

**【样例输出1】**

0.50000105

**【样例输入2】**

0.5236 50

**【样例输出2】**

0.50000106

**【样例说明】**

输入x为0.5236，n为4，求得sinx近似计算公式的值为0.50000105，小数点后保留8位；同样，输入x为0.5236，n为50，求得sinx近似计算公式的值为0.50000106，小数点后保留8位。注意：为保证数据的准确性和一致性，**请使用double数据类型保存计算结果。**

**【评分标准】**

该题要求输出上述公式的计算结果，共有5个测试点



```c
# include<stdio.h>
# include<math.h>

int main()
{
	double p=1.0,f,x;//p是阶乘中的变量，总量即分母是f 
	double s=0,t=-1;
	double i,j,n;
	scanf("%lf %lf",&x,&n);
	s=x;
	f=x;
	for(i=3;i<=2*n-1;i=i+2)
	{	p=p*i*(i-1);
		
	   	s=s+t*pow(x,i)/p;
	   	t=-t;
	} 
	printf("%.8lf",s);
 }
```

------



### 3.个人所得税

**【问题描述】**2019年1月1月新修订的个税法正式实施，个人所得税由之前的3500元提高到了5000元，还可以减去6项专项附加扣除，主要有子女教育、继续教育、赡养老人、大病医疗、住房贷款利息和住房租金，扣除三险一金和专项附加，工资大于5000元需要缴纳个人所得税，若小于5000元则不需要缴纳。2019年5000起征点个税表如下：

![1-1P91H2561V43.jpg](http://jsjjs.ctbu.edu.cn/userfiles/image/2019/15706296140540202339.jpg)

假设6项专项附加扣除为零。

请根据税率表编写代码，输入月收入和扣除的三险一金（单位：元），输出待交的个人所得税。

**注：个税的计算方法**

比如张先生在武汉工作每个月工资为10000元，公司每个月缴纳社保公积金扣除1300元，没有专项附加扣除费。那么张先生到手的工资为10000-1300-0=8700元，达到了个税起征点5000元，超出的部分按照10%的个人所得税率来计算，(8700-5000)*10%-210=160元，那么张先生一个月需要缴纳的个人所得税为160元。

**【输入形式】**用户在第一行输入月收入和三险一金(单位：元），中间用空格分开，第一个数是月收入，第二个数是三险一金
**【输出形式】**用户待交的个人所得税（单位：元），保留两位小数
**【样例输入】**10000 1300
**【样例输出】**160.00
**【样例说明】**输入的两个数中，第一个表示月收入，第二个数表示扣除的三险一金;输出待交的个人所得税
**【评分标准】**完全正确20分。提交源文件名为tax.c



```c
#include <stdio.h>
int main()
{
	int t;
	double m,l,p,tax;
	double rate,late; 
	scanf("%lf%lf",&l,&p);
	m=l-p-5000;

	if(m<=0)
	{
		tax=0;
	}
	else
	{
		if(m<=3000)	
			t=1;
		else if(m<=12000)
			t=2;
		else if(m<=25000)
			t=3;
		else if(m<=35000)
			t=4;
		else if(m<=55000)
			t=5;
		else if(m<=80000)
			t=6;
		else 
			t=7;
	
		switch(t)
		{
			case 1:
				rate=0.03,late=0;
				break;
			case 2:
				rate=0.10,late=210;
				break;
			case 3:
				rate=0.20,late=1410;
				break;
			case 4:
				rate=0.25,late=2660;
				break;
			case 5:
				rate=0.30,late=4410;
				break;
			case 6:
				rate=0.35,late=7160;
				break;
			case 7:
				rate=0.45,late=15160;		
		}
		tax=m*rate-late;
	}
	printf("需要缴纳的个人所得税为:%.2f 元",tax);
	return 0;
}
```





------



### 4.字符串复制

**【问题描述】**

编写一个字符串复制函数strCopy()，将字符串1中奇数位置的字符复制到另一个字符串2中，在主函数中调用函数strCopy()并输出复制后的结果。例如，当字符串1为"This is a C program"，则字符串2为"Ti saCporm"。

**【输入形式】**

输入字符串 

**【输出形式】**

输出复制后的字符串 

**【样例输入】**

This is a C Program 

**【样例输出】**

Ti saCporm 

```c
#include <stdio.h>
#include <string.h>

char *strCopy(char a[20])
{
    static char b[20];
    int j = 0;
    for (int i = 0; i < 20; i += 2, j++)
    {
        b[j]=a[i];
    }
    return b;
}

int main()
{
    char a[20];
    char *p = "";

    gets(a);
    printf("%s", strCopy(a));
}
```

------



### 5.还是三角形

**【问题描述】**

给定三条边，请判断三角形的类型。

**【输入形式】**

输入数据包含3个整数，表示三条边的长度，数据保证三条边一定能够组成三角形。

**【输出形式】**

请判断三条边组成的三角形类型（锐角三角形、钝角三角形、直角三角形、等腰三角形、等边三角形）。如果数据符合多种类型，则只输出优先度最高的类型（上面的五种三角形，优先级从低到高），具体输出格式参见样例。

**【样例输入】**

3 3 3

**【样例输出】**

 等边三角形



```c
#include <stdio.h>
#include <math.h> 
int Max(int a,int b,int c)
{    
    int t,max;    
    t=a>b?a:b;   
    max=t>c?t:c;   
    return max;
}

int Min(int a,int b,int c)
{    
    int t,min; 
    t=a<b?a:b; 
    min=t<c?t:c; 
    return min;
}

int Mid(int a,int b,int c)
{   
    int mid;    
    mid=a>b?(a<c?a:(b>c?b:c)):(b<c?b:(a>c?a:c)); 
    return mid;
}

int main()
{    
    int i,n;
	int a,b,c,k,x,y,z;             
	scanf("%d%d%d",&a,&b,&c);       
	if((a+b>c)&&(abs(a-b)<c))           
	{//  满足上面条件的三边可以构成三角形             
		if(a==b&&b==c)                
	     	printf("等边三角形\n");              
		else if((a==b&&c!=a)||(b==c&a!=b)||(a==c&&b!=a))           
	     		printf("等腰三角形\n");     
			 else                 
			{                    
	    		x=Min(a,b,c);         
				y=Mid(a,b,c);      
				z=Max(a,b,c);     
				if(x*x+y*y>z*z)                           
	  				printf("锐角三角形\n");                        
    			else if (a*a+b*b==c*c)                            
	  				printf("直角三角形\n");                        
				else if(x*x+y*y<z*z)                            
	  				printf("钝角三角形\n");                   
    		}           
	}       
	else//不满足构成三角形的条件           
    {                
		printf("这三边不能构成三角形\n");  
    }    
}
																		
```

------

### 6.寻找完全数

**【问题描述】**

完全数是特殊的自然数。它所有的真约数（即除了自身以外的约数）的和，恰好等于它本身。 第一个完全数是6，它有约数1、2、3、6，除去它本身6外，其余3个数相加，1+2+3=6 第二个完全数是28，它有约数1、2、4、7、14、28，除去它本身28外，其余5个数相加，1+2+4+7+14=28。 输入一个整数m，输出区间[1,m]内最大的完全数。

**【输入形式】**

输入一个整数。

**【输出形式】**

输出不超过m的最大完全数。

**【样例输入】**

32

**【样例输出】**

28

```c
#include <stdio.h>

int main()
{
	long long int m;
	long long int n=0,s=1;
	long long int i=1,j=2;
	long long int c;
	scanf("%ld",&m);
	
	for(i=m;i>=1;i--)
	{
		for(j=2;j<=i;j++)
		{ 
			s = i/j;
			if(i%j==0)
			n = n+s;
		}
		if(n==i)
		{
			c = i;
			break;
		}
		n = 0;
		
	}
	printf("%ld\n",c);
	return 0;
}
```

------

### 7.回文字符串



**【问题描述】**

回文字符串是具有回文特性的字符串：即该字符串从左向右读和从右向左读都一样，单独的字母不作为回文字符串，例如abcddcba即为一个长度为8的回文字符串。 编写一个程序，输入一个全是字母的字符串，找出字符串中最长的回文字符串，输出最长回文字符串的长度和最长的回文字符串（长度相同的输出第一个），若无回文字符串，只输出0。

**【输入形式】**

输入第一行为只含字母的字符串，长度不超过10000字符。 

**【输出形式】**

 输出结果第一行为最长回文字符串的长度输出结果第二行为最长的回文字符串

**【样例输入1】**

`abcdef`

**【样例输出1】**

`0`

**【样例输入2】**

`abcba`

**【样例输出2】**

`5 abcba`

**【样例输入3】**

`aAabccbaABcdcBA

**【样例输出3】**

`8 AabccbaA`



```c
#include<stdio.h>
#include<string.h>
#define LEN 100
/*
"最大回文子串是指个字行串中长度最大的回文字符串,其基本算法思想如下：
1、每个回文都有一个"中心"，当回文字符数为奇数时，中间的那个字符就是
回文中心，但是当回文的字数为偶数时,回文的中心是最中间的那两个字符,
且这两个字符相同。
2.对任一个字符或者相同的两个连续字符,我们都可以假设它为回文的"中心"，
向它的左右两边扩展出尽可能长的回文,对于每种假设,我们都能得到一个回文,
而最长回文必定由其中的某个假设中得到!*/


int Maxhw(char s[]) {
	int i,j,k,maxlen;
	int start=0;
	int slen=strlen(s);
	if(slen<1) return 0;
	maxlen=0;
	for(i=0;i<slen;i++) 
	{
    	for(j=0;(i-j>=0)&&(i+j<slen);j++)// 如果以i为中心是奇数的回文子串
		{
			if(s[i-j]!=s[i+j]) break;
			if(j*2+1>maxlen) 
			{
				start=i-j;
				maxlen=j*2+1;
			}
		}
		for(j=0;(i-j>=0)&&(i+j+1<slen);j++) // 如果以i为中心是偶数的回文子串
		{
			if(s[i-j]!=s[i+j+1]) break;
			if(j*2+2>maxlen) 
			{
				start=i-j;
				maxlen=j*2+2;
			}
		}
	}
	for (k=start;k<start+maxlen;k++) //输出最长回文串 
		printf("%c",s[k]);
	printf("\n");
	return maxlen; //返回最长回文串的长度 
}

int main()
{
	char ch[]="aAabccbaABcdcBA";
	//char ch[LEN];
	//gets(ch); 
	printf("%d\n",Maxhw(ch));
}
```



### 8.三种方法求Fabonacci数列

**本题要求实现求Fabonacci数列项的函数。**

Fabonacci数列的定义如下：*f*(*n*)=*f*(*n*−2)+*f*(*n*−1) (*n*≥2)，其中*f*(0)=0，*f*(1)=1。

**函数接口定义**：`int f( int n );`

函数`f`应返回第`n`个Fabonacci数。题目保证输入输出在长整型范围内。建议用递归实现。 



```c
//递归

#include <stdio.h>

int fib(int n)
{
	if(n==1||n==2) 
		return 1;
	else
		return fib(n-1)+fib(n-2);
 } 

int main()
{
    int n;
    scanf("%d",&n);
    printf("%d",fib(n));
}

```



```c
//递推

#include <stdio.h>

int main()
{
    int i,n,a=1,b=1;
    scanf("%d",&n);
    for (i=3;i<=(n+1)/2+1;i++) //递推求相应项的值 
	{    
	    	a=a+b;
			b=b+a;
	}
	if(n%2==1)
		printf("%d ",a);
	else
	   	printf("%d",b);	
}
```





```c
//数组方法

#include <stdio.h>
int main()
{
    int i,n,m;
    scanf("%d",&n);
    int fib[n];
    fib[0]=1;fib[1]=1;
    for(i=2;i<n;i++)
    {
        fib[i]=fib[i-1]+fib[i-2];
        
    }
    printf("%d",fib[n-1]);
}
```



------



### 9.相亲数

**【问题描述】**

2500年前数学大师毕达哥拉斯就发现，220和284两数之间存在着奇妙的联系： 220的因数之和（除了自身之外的因数）为：110+55+44+22+20+11+10+5+4+2+1=284，284的因数之和为：142+71+4+2+1=220。 毕达哥拉斯把这样的数对称为相亲数。输入两个正整数（大于1并且在int的表示范围之内），分别计算它们所有因数之和（除了自身之外的因数），并判断它们是否是一对相亲数。

**【输入形式】**

从标准输入输入两个正整数，以一个空格分隔这两个正整数。

**【输出形式】**

以输入的先后顺序分行输出：输入的正整数，后跟英文逗号&ldquo;,&rdquo;，再从除自身之外的最大的因数开始输出其因数相加的公式（最小的因数1之后没有加号），最后输出英文等号&ldquo;=&rdquo;和因数之和。注意：所有输出元素间无空格。 若它们是一对相亲数，则在新的一行上输出1；若不是则在新的一行上输出0。

**【样例输入1】**

220 284

**【样例输出1】**

220,110+55+44+22+20+11+10+5+4+2+1=284 284,142+71+4+2+1=220 1

**【样例输入2】**

2560 3282

**【样例输出2】**

2560,1280+640+512+320+256+160+128+80+64+40+32+20+16+10+8+5+4+2+1=3578 3282,1641+1094+547+6+3+2+1=3294 0

**【样例说明】**

样例1中输入的两个正整数为220和284，220的因数之和为284，284的因数之和为220，所以它们是一对相亲数，最后输出1； 例2中输入的两个正整数是2560和3282，2560的因数之和为3578，3282的因数之和为3294，所以它们不是一对相亲数，最后输出0。



```c
#include<stdio.h>
int p(int x)
{
	int i,n=0;
	printf("%d,",x);
	for(i=x-1;i>=1;i--)
    {
        if(x%i==0) 
		{
			printf("%d",i);
			n=n+i;
			if(i==1)
				printf("=");
			else
	 			printf("+");	
		}
	}		
   	printf("%d\n",n);
   	return n;
     
}
int main()
{
	int a,b,v;
	scanf("%d %d",&a,&b);
	v=p(a);
	p(b);
	if(v==b)
		printf("1");
	else
		printf("0");
	
}
```

------

### 10.计算天数

**【问题描述】**

定义一个结构体变量用以记录一个日期（包括年，月，日）。输入一个日期，计算该日是本年的第几天。 

**【输入形式】**

输入日期（包括年 月 日），是三个整数，以空格分隔。 

**【输出形式】**

输出该日是本年的第多少天。

 **【样例输入】**

 2003 3 25 

**【样例输出】**

 84 

**【样例说明】**

输入一个日期，输出该日是本年的第几天。 



```c
#include<stdio.h>
int Y(int year)
{	
	int g;
	if(year%400==0)
        g=1;
    else
    {
        if(year%4==0&&year%100!=0)
        	g=1;
        else
        	g=0;
    }
    if(g==1)
    {
       return 1;
	}
    else
    {
       return 2;
    }
}

int main()
{
	int a,b,c,sum;
	int i,k=0,n=0;
	scanf("%d %d %d",&a,&b,&c);
	if(Y(a)==1&&b>2)
	{
		for(i=b-1;i>=1;i--)
		{
			if(i%2==0)
				n++;
			else
				k++;
		}
		sum=31*k+30*n+c-1;
		printf("%d",sum);
	}
	if(Y(a)==2&&b>2)
	{
			for(i=b-1;i>=1;i--)
		{
			if(i%2==0)
				n++;
			else
				k++;
		}
		sum=31*k+30*n+c-2;
		printf("%d",sum);
	}
	if(b<=2)
	{
			for(i=b-1;i>=1;i--)
		{
			if(i%2==0)
				n++;
			else
				k++;
		}
		sum=31*k+30*n+c;
		printf("%d",sum);
	}
}

```



------

### 11.求最大公因子

**【问题描述】**

用递归方法编写求最大公因子程序。两个正整数x和y的最大公因子定义为：如果y<=x且x mod y＝0时，gcd(x,y)=y;如果y>x时，gcd(x,y)=gcd(y,x);其他情况，gcd(x,y)=gcd(y,x mod y) 

**【输入形式】**

用户在第一行输入两个数字，数字之间用空格分割。

 **【输出形式】**

程序在下一行输出前面输入的两个数字的最大公因子。 

**【样例输入】**

36 24 

**【样例输出】**

12 

**【样例说明】**

用户输入36，24，程序输出它们的最大公因子12 



```c
#include<stdio.h>
int f(int x,int y)
{
	if(x%y==0) 
		return y;
     else 
	 	f(y,x%y);  
}
int main()
{
	int a,b;
	scanf("%d %d",&a,&b);
	printf("%d",f(a,b));
}

```



### 12.整数合并

**【问题描述】** 

编写一函数int comb(int a,int b)，将两个两位数的正整数a、b合并形成一个整数并返回。合并的方式是：将a的十位和个位数依次放在结果的十位和千位上， b的十位和个位数依次放在结果的个位和百位上。例如，当a＝45，b=12。调用该函数后，返回5241。要求在main函数中调用该函数进行验证：从键盘输入两个整数，然后调用该函数进行合并，并输出合并后的结果。 

**【输入形式】**

 输入两个两位数的正整数，以空格隔开。

**【输出形式】**

输出合并后的正整数。 

**【输入样例】** 

45 12 

**【输出样例】**

 5241



```c
#include<stdio.h>
int main()
{
	int a,b;
	int sum,c,d,e,f;
	scanf("%d %d",&a,&b);
	c=(a%10)*1000;
	a=a/10;
	d=(a%10)*10;

	e=(b%10)*100;
	b=b/10;
	f=(b%10);
	sum=c+d+e+f;
	printf("%d",sum);
}

```





暂时就更新到这里吧